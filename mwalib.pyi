# This file is automatically generated by pyo3_stub_gen
# ruff: noqa: E501, F401

import builtins
import datetime
import enum
import numpy
import numpy.typing
import typing

@typing.final
class Antenna:
    r"""
    Structure for storing MWA antennas (tiles without polarisation) information from the metafits file
    """
    @property
    def ant(self) -> builtins.int:
        r"""
        This is the antenna number.
        Nominally this is the field we sort by to get the desired output order of antenna.
        X and Y have the same antenna number. This is the sorted ordinal order of the antenna.None
        e.g. 0...N-1
        """
    @ant.setter
    def ant(self, value: builtins.int) -> None:
        r"""
        This is the antenna number.
        Nominally this is the field we sort by to get the desired output order of antenna.
        X and Y have the same antenna number. This is the sorted ordinal order of the antenna.None
        e.g. 0...N-1
        """
    @property
    def tile_id(self) -> builtins.int:
        r"""
        Numeric part of tile_name for the antenna. Each pol has the same value
        e.g. tile_name "tile011" hsa tile_id of 11
        """
    @tile_id.setter
    def tile_id(self, value: builtins.int) -> None:
        r"""
        Numeric part of tile_name for the antenna. Each pol has the same value
        e.g. tile_name "tile011" hsa tile_id of 11
        """
    @property
    def tile_name(self) -> builtins.str:
        r"""
        Human readable name of the antenna
        X and Y have the same name
        """
    @tile_name.setter
    def tile_name(self, value: builtins.str) -> None:
        r"""
        Human readable name of the antenna
        X and Y have the same name
        """
    @property
    def rfinput_x(self) -> Rfinput:
        r"""
        Reference to the X pol rf_input
        """
    @rfinput_x.setter
    def rfinput_x(self, value: Rfinput) -> None:
        r"""
        Reference to the X pol rf_input
        """
    @property
    def rfinput_y(self) -> Rfinput:
        r"""
        Reference to the Y pol rf_input
        """
    @rfinput_y.setter
    def rfinput_y(self, value: Rfinput) -> None:
        r"""
        Reference to the Y pol rf_input
        """
    @property
    def electrical_length_m(self) -> builtins.float:
        r"""
        Note: the next 4 values are from the rfinput of which we have X and Y, however these values are the same for each pol so can be safely placed in the antenna struct
        for efficiency
        
        Electrical length in metres for this antenna and polarisation to the receiver.
        """
    @electrical_length_m.setter
    def electrical_length_m(self, value: builtins.float) -> None:
        r"""
        Note: the next 4 values are from the rfinput of which we have X and Y, however these values are the same for each pol so can be safely placed in the antenna struct
        for efficiency
        
        Electrical length in metres for this antenna and polarisation to the receiver.
        """
    @property
    def north_m(self) -> builtins.float:
        r"""
        Antenna position North from the array centre (metres)
        """
    @north_m.setter
    def north_m(self, value: builtins.float) -> None:
        r"""
        Antenna position North from the array centre (metres)
        """
    @property
    def east_m(self) -> builtins.float:
        r"""
        Antenna position East from the array centre (metres)
        """
    @east_m.setter
    def east_m(self, value: builtins.float) -> None:
        r"""
        Antenna position East from the array centre (metres)
        """
    @property
    def height_m(self) -> builtins.float:
        r"""
        Antenna height from the array centre (metres)
        """
    @height_m.setter
    def height_m(self, value: builtins.float) -> None:
        r"""
        Antenna height from the array centre (metres)
        """

@typing.final
class Baseline:
    r"""
    This is a struct for our baselines, so callers know the antenna ordering
    """
    @property
    def ant1_index(self) -> builtins.int:
        r"""
        Index in the mwalibContext.antenna array for antenna1 for this baseline
        """
    @ant1_index.setter
    def ant1_index(self, value: builtins.int) -> None:
        r"""
        Index in the mwalibContext.antenna array for antenna1 for this baseline
        """
    @property
    def ant2_index(self) -> builtins.int:
        r"""
        Index in the mwalibContext.antenna array for antenna2 for this baseline
        """
    @ant2_index.setter
    def ant2_index(self, value: builtins.int) -> None:
        r"""
        Index in the mwalibContext.antenna array for antenna2 for this baseline
        """

@typing.final
class CoarseChannel:
    r"""
    This is a struct for coarse channels
    """
    @property
    def corr_chan_number(self) -> builtins.int:
        r"""
        Correlator channel is 0 indexed (0..N-1)
        """
    @corr_chan_number.setter
    def corr_chan_number(self, value: builtins.int) -> None:
        r"""
        Correlator channel is 0 indexed (0..N-1)
        """
    @property
    def rec_chan_number(self) -> builtins.int:
        r"""
        Receiver channel is 0-255 in the RRI recivers
        """
    @rec_chan_number.setter
    def rec_chan_number(self, value: builtins.int) -> None:
        r"""
        Receiver channel is 0-255 in the RRI recivers
        """
    @property
    def gpubox_number(self) -> builtins.int:
        r"""
        gpubox channel number
        This is better described as the identifier which would be in the filename of visibility files
        Legacy e.g. obsid_datetime_gpuboxXX_00
        v2     e.g. obsid_datetime_gpuboxXXX_00
        """
    @gpubox_number.setter
    def gpubox_number(self, value: builtins.int) -> None:
        r"""
        gpubox channel number
        This is better described as the identifier which would be in the filename of visibility files
        Legacy e.g. obsid_datetime_gpuboxXX_00
        v2     e.g. obsid_datetime_gpuboxXXX_00
        """
    @property
    def chan_width_hz(self) -> builtins.int:
        r"""
        Width of a coarse channel in Hz
        """
    @chan_width_hz.setter
    def chan_width_hz(self, value: builtins.int) -> None:
        r"""
        Width of a coarse channel in Hz
        """
    @property
    def chan_start_hz(self) -> builtins.int:
        r"""
        Starting frequency of coarse channel in Hz
        """
    @chan_start_hz.setter
    def chan_start_hz(self, value: builtins.int) -> None:
        r"""
        Starting frequency of coarse channel in Hz
        """
    @property
    def chan_centre_hz(self) -> builtins.int:
        r"""
        Centre frequency of coarse channel in Hz
        """
    @chan_centre_hz.setter
    def chan_centre_hz(self, value: builtins.int) -> None:
        r"""
        Centre frequency of coarse channel in Hz
        """
    @property
    def chan_end_hz(self) -> builtins.int:
        r"""
        Ending frequency of coarse channel in Hz
        """
    @chan_end_hz.setter
    def chan_end_hz(self, value: builtins.int) -> None:
        r"""
        Ending frequency of coarse channel in Hz
        """

@typing.final
class CorrelatorContext:
    r"""
    This represents the basic metadata and methods for an MWA correlator observation.
    """
    @property
    def metafits_context(self) -> MetafitsContext:
        r"""
        Observation Metadata obtained from the metafits file
        """
    @metafits_context.setter
    def metafits_context(self, value: MetafitsContext) -> None:
        r"""
        Observation Metadata obtained from the metafits file
        """
    @property
    def mwa_version(self) -> MWAVersion:
        r"""
        MWA version, derived from the files passed in
        """
    @mwa_version.setter
    def mwa_version(self, value: MWAVersion) -> None:
        r"""
        MWA version, derived from the files passed in
        """
    @property
    def timesteps(self) -> builtins.list[TimeStep]:
        r"""
        This is an array of all known timesteps (union of metafits and provided timesteps from data files). The only exception is when the metafits timesteps are
        offset from the provided timesteps, in which case see description in `timestep::populate_metafits_provided_superset_of_timesteps`.
        """
    @timesteps.setter
    def timesteps(self, value: builtins.list[TimeStep]) -> None:
        r"""
        This is an array of all known timesteps (union of metafits and provided timesteps from data files). The only exception is when the metafits timesteps are
        offset from the provided timesteps, in which case see description in `timestep::populate_metafits_provided_superset_of_timesteps`.
        """
    @property
    def num_timesteps(self) -> builtins.int:
        r"""
        Number of timesteps in the timesteps vector
        """
    @num_timesteps.setter
    def num_timesteps(self, value: builtins.int) -> None:
        r"""
        Number of timesteps in the timesteps vector
        """
    @property
    def coarse_chans(self) -> builtins.list[CoarseChannel]:
        r"""
        Vector of coarse channel structs which is the same as the metafits provided coarse channels
        """
    @coarse_chans.setter
    def coarse_chans(self, value: builtins.list[CoarseChannel]) -> None:
        r"""
        Vector of coarse channel structs which is the same as the metafits provided coarse channels
        """
    @property
    def num_coarse_chans(self) -> builtins.int:
        r"""
        Number of coarse channels in the coarse channel vector
        """
    @num_coarse_chans.setter
    def num_coarse_chans(self, value: builtins.int) -> None:
        r"""
        Number of coarse channels in the coarse channel vector
        """
    @property
    def common_timestep_indices(self) -> builtins.list[builtins.int]:
        r"""
        Vector of (in)common timestep indices
        """
    @common_timestep_indices.setter
    def common_timestep_indices(self, value: builtins.list[builtins.int]) -> None:
        r"""
        Vector of (in)common timestep indices
        """
    @property
    def num_common_timesteps(self) -> builtins.int:
        r"""
        Number of common timesteps
        """
    @num_common_timesteps.setter
    def num_common_timesteps(self, value: builtins.int) -> None:
        r"""
        Number of common timesteps
        """
    @property
    def common_coarse_chan_indices(self) -> builtins.list[builtins.int]:
        r"""
        Vector of (in)common coarse channel indices
        """
    @common_coarse_chan_indices.setter
    def common_coarse_chan_indices(self, value: builtins.list[builtins.int]) -> None:
        r"""
        Vector of (in)common coarse channel indices
        """
    @property
    def num_common_coarse_chans(self) -> builtins.int:
        r"""
        Number of common coarse channels
        """
    @num_common_coarse_chans.setter
    def num_common_coarse_chans(self, value: builtins.int) -> None:
        r"""
        Number of common coarse channels
        """
    @property
    def common_start_unix_time_ms(self) -> builtins.int:
        r"""
        The start of the observation (the time that is common to all
        provided gpubox files).
        """
    @common_start_unix_time_ms.setter
    def common_start_unix_time_ms(self, value: builtins.int) -> None:
        r"""
        The start of the observation (the time that is common to all
        provided gpubox files).
        """
    @property
    def common_end_unix_time_ms(self) -> builtins.int:
        r"""
        `end_unix_time_ms` is the common end time of the observation
        i.e. start time of last common timestep plus integration time.
        """
    @common_end_unix_time_ms.setter
    def common_end_unix_time_ms(self, value: builtins.int) -> None:
        r"""
        `end_unix_time_ms` is the common end time of the observation
        i.e. start time of last common timestep plus integration time.
        """
    @property
    def common_start_gps_time_ms(self) -> builtins.int:
        r"""
        `start_unix_time_ms` but in GPS milliseconds
        """
    @common_start_gps_time_ms.setter
    def common_start_gps_time_ms(self, value: builtins.int) -> None:
        r"""
        `start_unix_time_ms` but in GPS milliseconds
        """
    @property
    def common_end_gps_time_ms(self) -> builtins.int:
        r"""
        `end_unix_time_ms` but in GPS milliseconds
        """
    @common_end_gps_time_ms.setter
    def common_end_gps_time_ms(self, value: builtins.int) -> None:
        r"""
        `end_unix_time_ms` but in GPS milliseconds
        """
    @property
    def common_duration_ms(self) -> builtins.int:
        r"""
        Total duration of common timesteps
        """
    @common_duration_ms.setter
    def common_duration_ms(self, value: builtins.int) -> None:
        r"""
        Total duration of common timesteps
        """
    @property
    def common_bandwidth_hz(self) -> builtins.int:
        r"""
        Total bandwidth of the common coarse channels
        """
    @common_bandwidth_hz.setter
    def common_bandwidth_hz(self, value: builtins.int) -> None:
        r"""
        Total bandwidth of the common coarse channels
        """
    @property
    def common_good_timestep_indices(self) -> builtins.list[builtins.int]:
        r"""
        Vector of (in)common timestep indices only including timesteps after the quack time
        """
    @common_good_timestep_indices.setter
    def common_good_timestep_indices(self, value: builtins.list[builtins.int]) -> None:
        r"""
        Vector of (in)common timestep indices only including timesteps after the quack time
        """
    @property
    def num_common_good_timesteps(self) -> builtins.int:
        r"""
        Number of common timesteps only including timesteps after the quack time
        """
    @num_common_good_timesteps.setter
    def num_common_good_timesteps(self, value: builtins.int) -> None:
        r"""
        Number of common timesteps only including timesteps after the quack time
        """
    @property
    def common_good_coarse_chan_indices(self) -> builtins.list[builtins.int]:
        r"""
        Vector of (in)common coarse channel indices only including timesteps after the quack time
        """
    @common_good_coarse_chan_indices.setter
    def common_good_coarse_chan_indices(self, value: builtins.list[builtins.int]) -> None:
        r"""
        Vector of (in)common coarse channel indices only including timesteps after the quack time
        """
    @property
    def num_common_good_coarse_chans(self) -> builtins.int:
        r"""
        Number of common coarse channels only including timesteps after the quack time
        """
    @num_common_good_coarse_chans.setter
    def num_common_good_coarse_chans(self, value: builtins.int) -> None:
        r"""
        Number of common coarse channels only including timesteps after the quack time
        """
    @property
    def common_good_start_unix_time_ms(self) -> builtins.int:
        r"""
        The start of the observation (the time that is common to all
        provided gpubox files) only including timesteps after the quack time
        """
    @common_good_start_unix_time_ms.setter
    def common_good_start_unix_time_ms(self, value: builtins.int) -> None:
        r"""
        The start of the observation (the time that is common to all
        provided gpubox files) only including timesteps after the quack time
        """
    @property
    def common_good_end_unix_time_ms(self) -> builtins.int:
        r"""
        `end_unix_time_ms` is the common end time of the observation only including timesteps after the quack time
        i.e. start time of last common timestep plus integration time.
        """
    @common_good_end_unix_time_ms.setter
    def common_good_end_unix_time_ms(self, value: builtins.int) -> None:
        r"""
        `end_unix_time_ms` is the common end time of the observation only including timesteps after the quack time
        i.e. start time of last common timestep plus integration time.
        """
    @property
    def common_good_start_gps_time_ms(self) -> builtins.int:
        r"""
        `common_good_start_unix_time_ms` but in GPS milliseconds
        """
    @common_good_start_gps_time_ms.setter
    def common_good_start_gps_time_ms(self, value: builtins.int) -> None:
        r"""
        `common_good_start_unix_time_ms` but in GPS milliseconds
        """
    @property
    def common_good_end_gps_time_ms(self) -> builtins.int:
        r"""
        `common_good_end_unix_time_ms` but in GPS milliseconds
        """
    @common_good_end_gps_time_ms.setter
    def common_good_end_gps_time_ms(self, value: builtins.int) -> None:
        r"""
        `common_good_end_unix_time_ms` but in GPS milliseconds
        """
    @property
    def common_good_duration_ms(self) -> builtins.int:
        r"""
        Total duration of common_good timesteps
        """
    @common_good_duration_ms.setter
    def common_good_duration_ms(self, value: builtins.int) -> None:
        r"""
        Total duration of common_good timesteps
        """
    @property
    def common_good_bandwidth_hz(self) -> builtins.int:
        r"""
        Total bandwidth of the common coarse channels only including timesteps after the quack time
        """
    @common_good_bandwidth_hz.setter
    def common_good_bandwidth_hz(self, value: builtins.int) -> None:
        r"""
        Total bandwidth of the common coarse channels only including timesteps after the quack time
        """
    @property
    def provided_timestep_indices(self) -> builtins.list[builtins.int]:
        r"""
        The indices of any timesteps which we have *some* data for
        """
    @provided_timestep_indices.setter
    def provided_timestep_indices(self, value: builtins.list[builtins.int]) -> None:
        r"""
        The indices of any timesteps which we have *some* data for
        """
    @property
    def num_provided_timesteps(self) -> builtins.int:
        r"""
        Number of provided timestep indices we have at least *some* data for
        """
    @num_provided_timesteps.setter
    def num_provided_timesteps(self, value: builtins.int) -> None:
        r"""
        Number of provided timestep indices we have at least *some* data for
        """
    @property
    def provided_coarse_chan_indices(self) -> builtins.list[builtins.int]:
        r"""
        The indices of any coarse channels which we have *some* data for
        """
    @provided_coarse_chan_indices.setter
    def provided_coarse_chan_indices(self, value: builtins.list[builtins.int]) -> None:
        r"""
        The indices of any coarse channels which we have *some* data for
        """
    @property
    def num_provided_coarse_chans(self) -> builtins.int:
        r"""
        Number of provided coarse channel indices we have at least *some* data for
        """
    @num_provided_coarse_chans.setter
    def num_provided_coarse_chans(self, value: builtins.int) -> None:
        r"""
        Number of provided coarse channel indices we have at least *some* data for
        """
    @property
    def num_timestep_coarse_chan_bytes(self) -> builtins.int:
        r"""
        The number of bytes taken up by a scan/timestep in each gpubox file.
        """
    @num_timestep_coarse_chan_bytes.setter
    def num_timestep_coarse_chan_bytes(self, value: builtins.int) -> None:
        r"""
        The number of bytes taken up by a scan/timestep in each gpubox file.
        """
    @property
    def num_timestep_coarse_chan_floats(self) -> builtins.int:
        r"""
        The number of floats in each gpubox visibility HDU.
        """
    @num_timestep_coarse_chan_floats.setter
    def num_timestep_coarse_chan_floats(self, value: builtins.int) -> None:
        r"""
        The number of floats in each gpubox visibility HDU.
        """
    @property
    def num_timestep_coarse_chan_weight_floats(self) -> builtins.int:
        r"""
        The number of floats in each gpubox weights HDU.
        """
    @num_timestep_coarse_chan_weight_floats.setter
    def num_timestep_coarse_chan_weight_floats(self, value: builtins.int) -> None:
        r"""
        The number of floats in each gpubox weights HDU.
        """
    @property
    def num_gpubox_files(self) -> builtins.int:
        r"""
        This is the number of gpubox files *per batch*.
        """
    @num_gpubox_files.setter
    def num_gpubox_files(self, value: builtins.int) -> None:
        r"""
        This is the number of gpubox files *per batch*.
        """
    @property
    def gpubox_batches(self) -> builtins.list[GpuBoxBatch]:
        r"""
        `gpubox_batches` *must* be sorted appropriately. See
        `gpubox::determine_gpubox_batches`. The order of the filenames
        corresponds directly to other gpubox-related objects
        (e.g. `gpubox_hdu_limits`). Structured:
        `gpubox_batches[batch][filename]`.
        """
    @gpubox_batches.setter
    def gpubox_batches(self, value: builtins.list[GpuBoxBatch]) -> None:
        r"""
        `gpubox_batches` *must* be sorted appropriately. See
        `gpubox::determine_gpubox_batches`. The order of the filenames
        corresponds directly to other gpubox-related objects
        (e.g. `gpubox_hdu_limits`). Structured:
        `gpubox_batches[batch][filename]`.
        """
    @property
    def gpubox_time_map(self) -> builtins.dict[builtins.int, builtins.dict[builtins.int, tuple[builtins.int, builtins.int]]]:
        r"""
        We assume as little as possible about the data layout in the gpubox
        files; here, a `BTreeMap` contains each unique UNIX time from every
        gpubox, which is associated with another `BTreeMap`, associating each
        gpubox number with a gpubox batch number and HDU index. The gpubox
        number, batch number and HDU index are everything needed to find the
        correct HDU out of all gpubox files.
        """
    @gpubox_time_map.setter
    def gpubox_time_map(self, value: builtins.dict[builtins.int, builtins.dict[builtins.int, tuple[builtins.int, builtins.int]]]) -> None:
        r"""
        We assume as little as possible about the data layout in the gpubox
        files; here, a `BTreeMap` contains each unique UNIX time from every
        gpubox, which is associated with another `BTreeMap`, associating each
        gpubox number with a gpubox batch number and HDU index. The gpubox
        number, batch number and HDU index are everything needed to find the
        correct HDU out of all gpubox files.
        """
    @property
    def legacy_conversion_table(self) -> builtins.list[LegacyConversionBaseline]:
        r"""
        A conversion table to optimise reading of legacy MWA HDUs
        """
    @legacy_conversion_table.setter
    def legacy_conversion_table(self, value: builtins.list[LegacyConversionBaseline]) -> None:
        r"""
        A conversion table to optimise reading of legacy MWA HDUs
        """
    @property
    def bscale(self) -> builtins.float:
        r"""
        BSCALE- FITS BSCALE or SCALEFAC value set on the visibility HDUs (used in Legacy Correlator only)
        """
    @bscale.setter
    def bscale(self, value: builtins.float) -> None:
        r"""
        BSCALE- FITS BSCALE or SCALEFAC value set on the visibility HDUs (used in Legacy Correlator only)
        """
    def __new__(cls, metafits_filename: builtins.str, gpubox_filenames: typing.Sequence[builtins.str]) -> CorrelatorContext:
        r"""
        From a path to a metafits file and paths to gpubox files, create a `CorrelatorContext`.
        
        Args:
            metafits_filename (str): filename of metafits file as a path or string.
            gpubox_filenames (list[str]): list of filenames of gpubox files.
        
        Returns:
            correlator_context (CorelatorContext): a populated CorrelatorContext object if Ok.
        """
    def get_fine_chan_freqs_hz_array(self, corr_coarse_chan_indices: typing.Sequence[builtins.int]) -> builtins.list[builtins.float]:
        r"""
        For a given list of correlator coarse channel indices, return a list of the center frequencies for all the fine channels in the given coarse channels
        
        Args:
            corr_coarse_chan_indices (list[int]): a list containing correlator coarse channel indices for which you want fine channels for. Does not need to be contiguous.
        
        Returns:
            fine_chan_freqs_hz_array (list[float]): a vector of floats containing the centre sky frequencies of all the fine channels for the given coarse channels.
        """
    def read_by_baseline(self, corr_timestep_index: builtins.int, corr_coarse_chan_index: builtins.int) -> numpy.typing.NDArray[numpy.float32]:
        r"""
        Read a single timestep for a single coarse channel. The output visibilities are in order: baseline,frequency,pol,r,i
        
        Args:
            corr_timestep_index (int): index within the CorrelatorContext timestep array for the desired timestep. This corresponds to the element within CorrelatorContext.timesteps.
            corr_coarse_chan_index (int): index within the CorrelatorContext coarse_chan array for the desired coarse channel. This corresponds to the element within CorrelatorContext.coarse_chans.
        
        Returns:
            data (numpy.typing.NDArray[numpy.float32]): 3 dimensional ndarray of 32 bit floats containing the data in [baseline],[frequency],[pol,r,i] order, if Ok.
        """
    def read_by_frequency(self, corr_timestep_index: builtins.int, corr_coarse_chan_index: builtins.int) -> numpy.typing.NDArray[numpy.float32]:
        r"""
        Read a single timestep for a single coarse channel. The output visibilities are in order: frequency,baseline,pol,r,i
        
        Args:
            corr_timestep_index (int): index within the CorrelatorContext timestep array for the desired timestep. This corresponds to the element within CorrelatorContext.timesteps.
            corr_coarse_chan_index (int): index within the CorrelatorContext coarse_chan array for the desired coarse channel. This corresponds to the element within CorrelatorContext.coarse_chans.
        
        Returns:
            data (numpy.typing.NDArray[numpy.float32]): 3 dimensional ndarray of 32 bit floats containing the data in [frequency],[baseline],[pol,r,i] order, if Ok.
        """
    def read_weights_by_baseline(self, corr_timestep_index: builtins.int, corr_coarse_chan_index: builtins.int) -> numpy.typing.NDArray[numpy.float32]:
        r"""
        Read weights for a single timestep for a single coarse channel. The output weights are in order: baseline,pol
        
        Args:
            corr_timestep_index (int): index within the CorrelatorContext timestep array for the desired timestep. This corresponds to the element within CorrelatorContext.timesteps.
            corr_coarse_chan_index (int): index within the CorrelatorContext coarse_chan array for the desired coarse channel. This corresponds to the element within CorrelatorContext.coarse_chans.
        
        Returns:
            data (numpy.typing.NDArray[numpy.float32]): A 2 dimensional ndarray of 32 bit floats containing the data in [baseline],[pol] order, if Ok.
        """
    def __repr__(self) -> builtins.str: ...
    def __enter__(self, slf: CorrelatorContext) -> CorrelatorContext: ...
    def __exit__(self, _exc_type: typing.Any, _exc_value: typing.Any, _traceback: typing.Any) -> None: ...

@typing.final
class GpuBoxBatch:
    r"""
    This represents one group of gpubox files with the same "batch" identitifer.
    e.g. obsid_datetime_chan_batch
    """
    @property
    def batch_number(self) -> builtins.int:
        r"""
        Batch number: 00,01,02..n.
        """
    @batch_number.setter
    def batch_number(self, value: builtins.int) -> None:
        r"""
        Batch number: 00,01,02..n.
        """
    @property
    def gpubox_files(self) -> builtins.list[GpuBoxFile]:
        r"""
        Vector storing the details of each gpubox file in this batch
        """
    @gpubox_files.setter
    def gpubox_files(self, value: builtins.list[GpuBoxFile]) -> None:
        r"""
        Vector storing the details of each gpubox file in this batch
        """

@typing.final
class GpuBoxFile:
    r"""
    This represents one gpubox file
    """
    @property
    def filename(self) -> builtins.str:
        r"""
        Filename of gpubox file
        """
    @filename.setter
    def filename(self, value: builtins.str) -> None:
        r"""
        Filename of gpubox file
        """
    @property
    def channel_identifier(self) -> builtins.int:
        r"""
        channel number (Legacy==gpubox host number 01..24; V2==receiver channel number 001..255)
        """
    @channel_identifier.setter
    def channel_identifier(self, value: builtins.int) -> None:
        r"""
        channel number (Legacy==gpubox host number 01..24; V2==receiver channel number 001..255)
        """

class GpuboxErrorBatchMissing(builtins.Exception):
    ...

class GpuboxErrorCorrVerMismatch(builtins.Exception):
    ...

class GpuboxErrorEmptyBTreeMap(builtins.Exception):
    ...

class GpuboxErrorFits(builtins.Exception):
    ...

class GpuboxErrorInvalidCoarseChanIndex(builtins.Exception):
    ...

class GpuboxErrorInvalidMwaVersion(builtins.Exception):
    ...

class GpuboxErrorInvalidTimeStepIndex(builtins.Exception):
    ...

class GpuboxErrorLegacyNaxis1Mismatch(builtins.Exception):
    ...

class GpuboxErrorLegacyNaxis2Mismatch(builtins.Exception):
    ...

class GpuboxErrorMissingObsid(builtins.Exception):
    ...

class GpuboxErrorMixture(builtins.Exception):
    ...

class GpuboxErrorMwaxCorrVerMismatch(builtins.Exception):
    ...

class GpuboxErrorMwaxCorrVerMissing(builtins.Exception):
    ...

class GpuboxErrorMwaxNaxis1Mismatch(builtins.Exception):
    ...

class GpuboxErrorMwaxNaxis2Mismatch(builtins.Exception):
    ...

class GpuboxErrorNoDataForTimeStepCoarseChannel(builtins.Exception):
    ...

class GpuboxErrorNoDataHDUsInGpuboxFile(builtins.Exception):
    ...

class GpuboxErrorNoGpuboxes(builtins.Exception):
    ...

class GpuboxErrorObsidMismatch(builtins.Exception):
    ...

class GpuboxErrorUnequalHduSizes(builtins.Exception):
    ...

class GpuboxErrorUnevenCountInBatches(builtins.Exception):
    ...

class GpuboxErrorUnrecognised(builtins.Exception):
    ...

@typing.final
class LegacyConversionBaseline:
    r"""
    Structure for storing where in the input visibilities to get the specified baseline when converting
    """
    @property
    def baseline(self) -> builtins.int: ...
    @baseline.setter
    def baseline(self, value: builtins.int) -> None: ...
    @property
    def ant1(self) -> builtins.int: ...
    @ant1.setter
    def ant1(self, value: builtins.int) -> None: ...
    @property
    def ant2(self) -> builtins.int: ...
    @ant2.setter
    def ant2(self, value: builtins.int) -> None: ...
    @property
    def xx_index(self) -> builtins.int: ...
    @xx_index.setter
    def xx_index(self, value: builtins.int) -> None: ...
    @property
    def xx_conjugate(self) -> builtins.bool: ...
    @xx_conjugate.setter
    def xx_conjugate(self, value: builtins.bool) -> None: ...
    @property
    def xy_index(self) -> builtins.int: ...
    @xy_index.setter
    def xy_index(self, value: builtins.int) -> None: ...
    @property
    def xy_conjugate(self) -> builtins.bool: ...
    @xy_conjugate.setter
    def xy_conjugate(self, value: builtins.bool) -> None: ...
    @property
    def yx_index(self) -> builtins.int: ...
    @yx_index.setter
    def yx_index(self, value: builtins.int) -> None: ...
    @property
    def yx_conjugate(self) -> builtins.bool: ...
    @yx_conjugate.setter
    def yx_conjugate(self, value: builtins.bool) -> None: ...
    @property
    def yy_index(self) -> builtins.int: ...
    @yy_index.setter
    def yy_index(self, value: builtins.int) -> None: ...
    @property
    def yy_conjugate(self) -> builtins.bool: ...
    @yy_conjugate.setter
    def yy_conjugate(self, value: builtins.bool) -> None: ...

@typing.final
class MetafitsContext:
    r"""
    Metafits context. This represents the basic metadata for an MWA observation.
    """
    @property
    def mwa_version(self) -> typing.Optional[MWAVersion]:
        r"""
        mwa version
        """
    @mwa_version.setter
    def mwa_version(self, value: typing.Optional[MWAVersion]) -> None:
        r"""
        mwa version
        """
    @property
    def obs_id(self) -> builtins.int:
        r"""
        Observation id
        """
    @obs_id.setter
    def obs_id(self, value: builtins.int) -> None:
        r"""
        Observation id
        """
    @property
    def sched_start_gps_time_ms(self) -> builtins.int:
        r"""
        Scheduled start (gps time) of observation
        """
    @sched_start_gps_time_ms.setter
    def sched_start_gps_time_ms(self, value: builtins.int) -> None:
        r"""
        Scheduled start (gps time) of observation
        """
    @property
    def sched_end_gps_time_ms(self) -> builtins.int:
        r"""
        Scheduled end (gps time) of observation
        """
    @sched_end_gps_time_ms.setter
    def sched_end_gps_time_ms(self, value: builtins.int) -> None:
        r"""
        Scheduled end (gps time) of observation
        """
    @property
    def sched_start_unix_time_ms(self) -> builtins.int:
        r"""
        Scheduled start (UNIX time) of observation
        """
    @sched_start_unix_time_ms.setter
    def sched_start_unix_time_ms(self, value: builtins.int) -> None:
        r"""
        Scheduled start (UNIX time) of observation
        """
    @property
    def sched_end_unix_time_ms(self) -> builtins.int:
        r"""
        Scheduled end (UNIX time) of observation
        """
    @sched_end_unix_time_ms.setter
    def sched_end_unix_time_ms(self, value: builtins.int) -> None:
        r"""
        Scheduled end (UNIX time) of observation
        """
    @property
    def sched_start_utc(self) -> datetime.datetime:
        r"""
        Scheduled start (UTC) of observation
        """
    @sched_start_utc.setter
    def sched_start_utc(self, value: datetime.datetime) -> None:
        r"""
        Scheduled start (UTC) of observation
        """
    @property
    def sched_end_utc(self) -> datetime.datetime:
        r"""
        Scheduled end (UTC) of observation
        """
    @sched_end_utc.setter
    def sched_end_utc(self, value: datetime.datetime) -> None:
        r"""
        Scheduled end (UTC) of observation
        """
    @property
    def sched_start_mjd(self) -> builtins.float:
        r"""
        Scheduled start (MJD) of observation
        """
    @sched_start_mjd.setter
    def sched_start_mjd(self, value: builtins.float) -> None:
        r"""
        Scheduled start (MJD) of observation
        """
    @property
    def sched_end_mjd(self) -> builtins.float:
        r"""
        Scheduled end (MJD) of observation
        """
    @sched_end_mjd.setter
    def sched_end_mjd(self, value: builtins.float) -> None:
        r"""
        Scheduled end (MJD) of observation
        """
    @property
    def sched_duration_ms(self) -> builtins.int:
        r"""
        Scheduled duration of observation
        """
    @sched_duration_ms.setter
    def sched_duration_ms(self, value: builtins.int) -> None:
        r"""
        Scheduled duration of observation
        """
    @property
    def dut1(self) -> typing.Optional[builtins.float]:
        r"""
        DUT1 (i.e. UTC-UT1). The UTC of the obsid is used to determine this
        value. Calculated by astropy. Made optional for compatibility.
        """
    @dut1.setter
    def dut1(self, value: typing.Optional[builtins.float]) -> None:
        r"""
        DUT1 (i.e. UTC-UT1). The UTC of the obsid is used to determine this
        value. Calculated by astropy. Made optional for compatibility.
        """
    @property
    def ra_tile_pointing_degrees(self) -> builtins.float:
        r"""
        RA tile pointing
        """
    @ra_tile_pointing_degrees.setter
    def ra_tile_pointing_degrees(self, value: builtins.float) -> None:
        r"""
        RA tile pointing
        """
    @property
    def dec_tile_pointing_degrees(self) -> builtins.float:
        r"""
        DEC tile pointing
        """
    @dec_tile_pointing_degrees.setter
    def dec_tile_pointing_degrees(self, value: builtins.float) -> None:
        r"""
        DEC tile pointing
        """
    @property
    def ra_phase_center_degrees(self) -> typing.Optional[builtins.float]:
        r"""
        RA phase centre
        """
    @ra_phase_center_degrees.setter
    def ra_phase_center_degrees(self, value: typing.Optional[builtins.float]) -> None:
        r"""
        RA phase centre
        """
    @property
    def dec_phase_center_degrees(self) -> typing.Optional[builtins.float]:
        r"""
        DEC phase centre
        """
    @dec_phase_center_degrees.setter
    def dec_phase_center_degrees(self, value: typing.Optional[builtins.float]) -> None:
        r"""
        DEC phase centre
        """
    @property
    def az_deg(self) -> builtins.float:
        r"""
        AZIMUTH of the pointing centre in degrees
        """
    @az_deg.setter
    def az_deg(self, value: builtins.float) -> None:
        r"""
        AZIMUTH of the pointing centre in degrees
        """
    @property
    def alt_deg(self) -> builtins.float:
        r"""
        ALTITUDE (a.k.a. elevation) of the pointing centre in degrees
        """
    @alt_deg.setter
    def alt_deg(self, value: builtins.float) -> None:
        r"""
        ALTITUDE (a.k.a. elevation) of the pointing centre in degrees
        """
    @property
    def za_deg(self) -> builtins.float:
        r"""
        Zenith angle of the pointing centre in degrees
        """
    @za_deg.setter
    def za_deg(self, value: builtins.float) -> None:
        r"""
        Zenith angle of the pointing centre in degrees
        """
    @property
    def az_rad(self) -> builtins.float:
        r"""
        AZIMUTH of the pointing centre in radians
        """
    @az_rad.setter
    def az_rad(self, value: builtins.float) -> None:
        r"""
        AZIMUTH of the pointing centre in radians
        """
    @property
    def alt_rad(self) -> builtins.float:
        r"""
        ALTITUDE (a.k.a. elevation) of the pointing centre in radians
        """
    @alt_rad.setter
    def alt_rad(self, value: builtins.float) -> None:
        r"""
        ALTITUDE (a.k.a. elevation) of the pointing centre in radians
        """
    @property
    def za_rad(self) -> builtins.float:
        r"""
        Zenith angle of the pointing centre in radians
        """
    @za_rad.setter
    def za_rad(self, value: builtins.float) -> None:
        r"""
        Zenith angle of the pointing centre in radians
        """
    @property
    def sun_alt_deg(self) -> typing.Optional[builtins.float]:
        r"""
        Altitude of Sun
        """
    @sun_alt_deg.setter
    def sun_alt_deg(self, value: typing.Optional[builtins.float]) -> None:
        r"""
        Altitude of Sun
        """
    @property
    def sun_distance_deg(self) -> typing.Optional[builtins.float]:
        r"""
        Distance from pointing center to Sun
        """
    @sun_distance_deg.setter
    def sun_distance_deg(self, value: typing.Optional[builtins.float]) -> None:
        r"""
        Distance from pointing center to Sun
        """
    @property
    def moon_distance_deg(self) -> typing.Optional[builtins.float]:
        r"""
        Distance from pointing center to the Moon
        """
    @moon_distance_deg.setter
    def moon_distance_deg(self, value: typing.Optional[builtins.float]) -> None:
        r"""
        Distance from pointing center to the Moon
        """
    @property
    def jupiter_distance_deg(self) -> typing.Optional[builtins.float]:
        r"""
        Distance from pointing center to Jupiter
        """
    @jupiter_distance_deg.setter
    def jupiter_distance_deg(self, value: typing.Optional[builtins.float]) -> None:
        r"""
        Distance from pointing center to Jupiter
        """
    @property
    def lst_deg(self) -> builtins.float:
        r"""
        Local Sidereal Time in degrees (at the midpoint of the observation)
        """
    @lst_deg.setter
    def lst_deg(self, value: builtins.float) -> None:
        r"""
        Local Sidereal Time in degrees (at the midpoint of the observation)
        """
    @property
    def lst_rad(self) -> builtins.float:
        r"""
        Local Sidereal Time in radians (at the midpoint of the observation)
        """
    @lst_rad.setter
    def lst_rad(self, value: builtins.float) -> None:
        r"""
        Local Sidereal Time in radians (at the midpoint of the observation)
        """
    @property
    def hour_angle_string(self) -> builtins.str:
        r"""
        Hour Angle of pointing center (as a string)
        """
    @hour_angle_string.setter
    def hour_angle_string(self, value: builtins.str) -> None:
        r"""
        Hour Angle of pointing center (as a string)
        """
    @property
    def grid_name(self) -> builtins.str:
        r"""
        GRIDNAME
        """
    @grid_name.setter
    def grid_name(self, value: builtins.str) -> None:
        r"""
        GRIDNAME
        """
    @property
    def grid_number(self) -> builtins.int:
        r"""
        GRIDNUM
        """
    @grid_number.setter
    def grid_number(self, value: builtins.int) -> None:
        r"""
        GRIDNUM
        """
    @property
    def creator(self) -> builtins.str:
        r"""
        CREATOR
        """
    @creator.setter
    def creator(self, value: builtins.str) -> None:
        r"""
        CREATOR
        """
    @property
    def project_id(self) -> builtins.str:
        r"""
        PROJECT
        """
    @project_id.setter
    def project_id(self, value: builtins.str) -> None:
        r"""
        PROJECT
        """
    @property
    def obs_name(self) -> builtins.str:
        r"""
        Observation name
        """
    @obs_name.setter
    def obs_name(self, value: builtins.str) -> None:
        r"""
        Observation name
        """
    @property
    def mode(self) -> MWAMode:
        r"""
        MWA observation mode
        """
    @mode.setter
    def mode(self, value: MWAMode) -> None:
        r"""
        MWA observation mode
        """
    @property
    def geometric_delays_applied(self) -> GeometricDelaysApplied:
        r"""
        Which Geometric delays have been applied to the data?
        """
    @geometric_delays_applied.setter
    def geometric_delays_applied(self, value: GeometricDelaysApplied) -> None:
        r"""
        Which Geometric delays have been applied to the data?
        """
    @property
    def cable_delays_applied(self) -> CableDelaysApplied:
        r"""
        Have cable delays been applied to the data?
        """
    @cable_delays_applied.setter
    def cable_delays_applied(self, value: CableDelaysApplied) -> None:
        r"""
        Have cable delays been applied to the data?
        """
    @property
    def calibration_delays_and_gains_applied(self) -> builtins.bool:
        r"""
        Have calibration delays and gains been applied to the data?
        """
    @calibration_delays_and_gains_applied.setter
    def calibration_delays_and_gains_applied(self, value: builtins.bool) -> None:
        r"""
        Have calibration delays and gains been applied to the data?
        """
    @property
    def corr_fine_chan_width_hz(self) -> builtins.int:
        r"""
        Correlator fine_chan_resolution
        """
    @corr_fine_chan_width_hz.setter
    def corr_fine_chan_width_hz(self, value: builtins.int) -> None:
        r"""
        Correlator fine_chan_resolution
        """
    @property
    def corr_int_time_ms(self) -> builtins.int:
        r"""
        Correlator mode dump time
        """
    @corr_int_time_ms.setter
    def corr_int_time_ms(self, value: builtins.int) -> None:
        r"""
        Correlator mode dump time
        """
    @property
    def corr_raw_scale_factor(self) -> builtins.float:
        r"""
        Correlator visibility scaling factor used to get the visibilities in Jansky-like units
        """
    @corr_raw_scale_factor.setter
    def corr_raw_scale_factor(self, value: builtins.float) -> None:
        r"""
        Correlator visibility scaling factor used to get the visibilities in Jansky-like units
        """
    @property
    def num_corr_fine_chans_per_coarse(self) -> builtins.int:
        r"""
        Number of fine channels in each coarse channel for a correlator observation
        """
    @num_corr_fine_chans_per_coarse.setter
    def num_corr_fine_chans_per_coarse(self, value: builtins.int) -> None:
        r"""
        Number of fine channels in each coarse channel for a correlator observation
        """
    @property
    def volt_fine_chan_width_hz(self) -> builtins.int:
        r"""
        Voltage fine_chan_resolution
        """
    @volt_fine_chan_width_hz.setter
    def volt_fine_chan_width_hz(self, value: builtins.int) -> None:
        r"""
        Voltage fine_chan_resolution
        """
    @property
    def num_volt_fine_chans_per_coarse(self) -> builtins.int:
        r"""
        Number of fine channels in each coarse channel for a voltage observation
        """
    @num_volt_fine_chans_per_coarse.setter
    def num_volt_fine_chans_per_coarse(self, value: builtins.int) -> None:
        r"""
        Number of fine channels in each coarse channel for a voltage observation
        """
    @property
    def receivers(self) -> builtins.list[builtins.int]:
        r"""
        Array of receiver numbers
        """
    @receivers.setter
    def receivers(self, value: builtins.list[builtins.int]) -> None:
        r"""
        Array of receiver numbers
        """
    @property
    def num_receivers(self) -> builtins.int:
        r"""
        Number of recievers
        """
    @num_receivers.setter
    def num_receivers(self, value: builtins.int) -> None:
        r"""
        Number of recievers
        """
    @property
    def delays(self) -> builtins.list[builtins.int]:
        r"""
        Array of beamformer delays
        """
    @delays.setter
    def delays(self, value: builtins.list[builtins.int]) -> None:
        r"""
        Array of beamformer delays
        """
    @property
    def num_delays(self) -> builtins.int:
        r"""
        Number of beamformer delays
        """
    @num_delays.setter
    def num_delays(self, value: builtins.int) -> None:
        r"""
        Number of beamformer delays
        """
    @property
    def calibrator(self) -> builtins.bool:
        r"""
        Intended for calibration
        """
    @calibrator.setter
    def calibrator(self, value: builtins.bool) -> None:
        r"""
        Intended for calibration
        """
    @property
    def calibrator_source(self) -> builtins.str:
        r"""
        Calibrator source
        """
    @calibrator_source.setter
    def calibrator_source(self, value: builtins.str) -> None:
        r"""
        Calibrator source
        """
    @property
    def global_analogue_attenuation_db(self) -> builtins.float:
        r"""
        ATTEN_DB  // global analogue attenuation, in dB
        """
    @global_analogue_attenuation_db.setter
    def global_analogue_attenuation_db(self, value: builtins.float) -> None:
        r"""
        ATTEN_DB  // global analogue attenuation, in dB
        """
    @property
    def quack_time_duration_ms(self) -> builtins.int:
        r"""
        Seconds of bad data after observation starts
        """
    @quack_time_duration_ms.setter
    def quack_time_duration_ms(self, value: builtins.int) -> None:
        r"""
        Seconds of bad data after observation starts
        """
    @property
    def good_time_unix_ms(self) -> builtins.int:
        r"""
        OBSID+QUACKTIM as Unix timestamp (first good timestep)
        """
    @good_time_unix_ms.setter
    def good_time_unix_ms(self, value: builtins.int) -> None:
        r"""
        OBSID+QUACKTIM as Unix timestamp (first good timestep)
        """
    @property
    def good_time_gps_ms(self) -> builtins.int:
        r"""
        Good time expressed in GPS seconds
        """
    @good_time_gps_ms.setter
    def good_time_gps_ms(self, value: builtins.int) -> None:
        r"""
        Good time expressed in GPS seconds
        """
    @property
    def num_ants(self) -> builtins.int:
        r"""
        Total number of antennas (tiles) in the array
        """
    @num_ants.setter
    def num_ants(self, value: builtins.int) -> None:
        r"""
        Total number of antennas (tiles) in the array
        """
    @property
    def antennas(self) -> builtins.list[Antenna]:
        r"""
        We also have just the antennas
        """
    @antennas.setter
    def antennas(self, value: builtins.list[Antenna]) -> None:
        r"""
        We also have just the antennas
        """
    @property
    def num_rf_inputs(self) -> builtins.int:
        r"""
        Total number of rf_inputs (tiles * 2 pols X&Y)
        """
    @num_rf_inputs.setter
    def num_rf_inputs(self, value: builtins.int) -> None:
        r"""
        Total number of rf_inputs (tiles * 2 pols X&Y)
        """
    @property
    def rf_inputs(self) -> builtins.list[Rfinput]:
        r"""
        The Metafits defines an rf chain for antennas(tiles) * pol(X,Y)
        """
    @rf_inputs.setter
    def rf_inputs(self, value: builtins.list[Rfinput]) -> None:
        r"""
        The Metafits defines an rf chain for antennas(tiles) * pol(X,Y)
        """
    @property
    def num_ant_pols(self) -> builtins.int:
        r"""
        Number of antenna pols. e.g. X and Y
        """
    @num_ant_pols.setter
    def num_ant_pols(self, value: builtins.int) -> None:
        r"""
        Number of antenna pols. e.g. X and Y
        """
    @property
    def num_metafits_timesteps(self) -> builtins.int:
        r"""
        Number of timesteps defined in the metafits file
        """
    @num_metafits_timesteps.setter
    def num_metafits_timesteps(self, value: builtins.int) -> None:
        r"""
        Number of timesteps defined in the metafits file
        """
    @property
    def metafits_timesteps(self) -> builtins.list[TimeStep]:
        r"""
        Vector of timesteps based on the metafits file
        """
    @metafits_timesteps.setter
    def metafits_timesteps(self, value: builtins.list[TimeStep]) -> None:
        r"""
        Vector of timesteps based on the metafits file
        """
    @property
    def num_metafits_coarse_chans(self) -> builtins.int:
        r"""
        Number of coarse channels based on the metafits file
        """
    @num_metafits_coarse_chans.setter
    def num_metafits_coarse_chans(self, value: builtins.int) -> None:
        r"""
        Number of coarse channels based on the metafits file
        """
    @property
    def metafits_coarse_chans(self) -> builtins.list[CoarseChannel]:
        r"""
        Vector of coarse channels based on the metafits file
        """
    @metafits_coarse_chans.setter
    def metafits_coarse_chans(self, value: builtins.list[CoarseChannel]) -> None:
        r"""
        Vector of coarse channels based on the metafits file
        """
    @property
    def num_metafits_fine_chan_freqs(self) -> builtins.int:
        r"""
        Number of fine channels for the whole observation
        """
    @num_metafits_fine_chan_freqs.setter
    def num_metafits_fine_chan_freqs(self, value: builtins.int) -> None:
        r"""
        Number of fine channels for the whole observation
        """
    @property
    def metafits_fine_chan_freqs_hz(self) -> builtins.list[builtins.float]:
        r"""
        Vector of fine channel frequencies for the whole observation
        """
    @metafits_fine_chan_freqs_hz.setter
    def metafits_fine_chan_freqs_hz(self, value: builtins.list[builtins.float]) -> None:
        r"""
        Vector of fine channel frequencies for the whole observation
        """
    @property
    def obs_bandwidth_hz(self) -> builtins.int:
        r"""
        Total bandwidth of observation assuming we have all coarse channels
        """
    @obs_bandwidth_hz.setter
    def obs_bandwidth_hz(self, value: builtins.int) -> None:
        r"""
        Total bandwidth of observation assuming we have all coarse channels
        """
    @property
    def coarse_chan_width_hz(self) -> builtins.int:
        r"""
        Bandwidth of each coarse channel
        """
    @coarse_chan_width_hz.setter
    def coarse_chan_width_hz(self, value: builtins.int) -> None:
        r"""
        Bandwidth of each coarse channel
        """
    @property
    def centre_freq_hz(self) -> builtins.int:
        r"""
        The value of the FREQCENT key in the metafits file, but in Hz.
        """
    @centre_freq_hz.setter
    def centre_freq_hz(self, value: builtins.int) -> None:
        r"""
        The value of the FREQCENT key in the metafits file, but in Hz.
        """
    @property
    def num_baselines(self) -> builtins.int:
        r"""
        Number of baselines stored. This is autos plus cross correlations
        """
    @num_baselines.setter
    def num_baselines(self, value: builtins.int) -> None:
        r"""
        Number of baselines stored. This is autos plus cross correlations
        """
    @property
    def baselines(self) -> builtins.list[Baseline]:
        r"""
        Baslines
        """
    @baselines.setter
    def baselines(self, value: builtins.list[Baseline]) -> None:
        r"""
        Baslines
        """
    @property
    def num_visibility_pols(self) -> builtins.int:
        r"""
        Number of polarisation combinations in the visibilities e.g. XX,XY,YX,YY == 4
        """
    @num_visibility_pols.setter
    def num_visibility_pols(self, value: builtins.int) -> None:
        r"""
        Number of polarisation combinations in the visibilities e.g. XX,XY,YX,YY == 4
        """
    @property
    def metafits_filename(self) -> builtins.str:
        r"""
        Filename of the metafits we were given
        """
    @metafits_filename.setter
    def metafits_filename(self, value: builtins.str) -> None:
        r"""
        Filename of the metafits we were given
        """
    @property
    def oversampled(self) -> builtins.bool:
        r"""
        Was this observation using oversampled coarse channels?
        """
    @oversampled.setter
    def oversampled(self, value: builtins.bool) -> None:
        r"""
        Was this observation using oversampled coarse channels?
        """
    @property
    def deripple_applied(self) -> builtins.bool:
        r"""
        Was deripple applied to this observation?
        """
    @deripple_applied.setter
    def deripple_applied(self, value: builtins.bool) -> None:
        r"""
        Was deripple applied to this observation?
        """
    @property
    def deripple_param(self) -> builtins.str:
        r"""
        What was the configured deripple_param?
        If deripple_applied is False then this deripple param was not applied
        """
    @deripple_param.setter
    def deripple_param(self, value: builtins.str) -> None:
        r"""
        What was the configured deripple_param?
        If deripple_applied is False then this deripple param was not applied
        """
    @property
    def best_cal_fit_id(self) -> typing.Optional[builtins.int]:
        r"""
        Best calibration fit ID
        """
    @best_cal_fit_id.setter
    def best_cal_fit_id(self, value: typing.Optional[builtins.int]) -> None:
        r"""
        Best calibration fit ID
        """
    @property
    def best_cal_obs_id(self) -> typing.Optional[builtins.int]:
        r"""
        Best calibration observation ID
        """
    @best_cal_obs_id.setter
    def best_cal_obs_id(self, value: typing.Optional[builtins.int]) -> None:
        r"""
        Best calibration observation ID
        """
    @property
    def best_cal_code_ver(self) -> typing.Optional[builtins.str]:
        r"""
        Best calibration fit code version
        """
    @best_cal_code_ver.setter
    def best_cal_code_ver(self, value: typing.Optional[builtins.str]) -> None:
        r"""
        Best calibration fit code version
        """
    @property
    def best_cal_fit_timestamp(self) -> typing.Optional[builtins.str]:
        r"""
        Best calibration fit timestamp
        """
    @best_cal_fit_timestamp.setter
    def best_cal_fit_timestamp(self, value: typing.Optional[builtins.str]) -> None:
        r"""
        Best calibration fit timestamp
        """
    @property
    def best_cal_creator(self) -> typing.Optional[builtins.str]:
        r"""
        Best calibration fit creator
        """
    @best_cal_creator.setter
    def best_cal_creator(self, value: typing.Optional[builtins.str]) -> None:
        r"""
        Best calibration fit creator
        """
    @property
    def best_cal_fit_iters(self) -> typing.Optional[builtins.int]:
        r"""
        Best calibration fit iterations
        """
    @best_cal_fit_iters.setter
    def best_cal_fit_iters(self, value: typing.Optional[builtins.int]) -> None:
        r"""
        Best calibration fit iterations
        """
    @property
    def best_cal_fit_iter_limit(self) -> typing.Optional[builtins.int]:
        r"""
        Best calibration fit iteration limit
        """
    @best_cal_fit_iter_limit.setter
    def best_cal_fit_iter_limit(self, value: typing.Optional[builtins.int]) -> None:
        r"""
        Best calibration fit iteration limit
        """
    @property
    def signal_chain_corrections(self) -> typing.Optional[builtins.list[SignalChainCorrection]]:
        r"""
        Signal Chain corrections
        """
    @signal_chain_corrections.setter
    def signal_chain_corrections(self, value: typing.Optional[builtins.list[SignalChainCorrection]]) -> None:
        r"""
        Signal Chain corrections
        """
    @property
    def num_signal_chain_corrections(self) -> builtins.int:
        r"""
        Number of Signal Chain corrections
        """
    @num_signal_chain_corrections.setter
    def num_signal_chain_corrections(self, value: builtins.int) -> None:
        r"""
        Number of Signal Chain corrections
        """
    def __new__(cls, metafits_filename: builtins.str, mwa_version: typing.Optional[MWAVersion] = None) -> MetafitsContext:
        r"""
        From a path to a metafits file, create a `MetafitsContext`.
        
        Args:
            metafits_filename (str): filename of metafits file.
            mwa_version (Optional[MWAVersion]): the MWA version the metafits should be interpreted as. Pass None to have mwalib guess based on the MODE in the metafits.
        
        Returns:
            metafits_contex (MetafitsContex): a populated MetafitsContext object if Ok.
        """
    def __repr__(self) -> builtins.str: ...
    def __enter__(self, slf: MetafitsContext) -> MetafitsContext: ...
    def __exit__(self, _exc_type: typing.Any, _exc_value: typing.Any, _traceback: typing.Any) -> None: ...

class MwalibError(builtins.Exception):
    ...

@typing.final
class Rfinput:
    r"""
    Structure for storing MWA rf_chains (tile with polarisation) information from the metafits file
    """
    @property
    def input(self) -> builtins.int:
        r"""
        This is the metafits order (0-n inputs)
        """
    @input.setter
    def input(self, value: builtins.int) -> None:
        r"""
        This is the metafits order (0-n inputs)
        """
    @property
    def ant(self) -> builtins.int:
        r"""
        This is the antenna number.
        Nominally this is the field we sort by to get the desired output order of antenna.
        X and Y have the same antenna number. This is the sorted ordinal order of the antenna.None
        e.g. 0...N-1
        """
    @ant.setter
    def ant(self, value: builtins.int) -> None:
        r"""
        This is the antenna number.
        Nominally this is the field we sort by to get the desired output order of antenna.
        X and Y have the same antenna number. This is the sorted ordinal order of the antenna.None
        e.g. 0...N-1
        """
    @property
    def tile_id(self) -> builtins.int:
        r"""
        Numeric part of tile_name for the antenna. Each pol has the same value
        e.g. tile_name "tile011" hsa tile_id of 11
        """
    @tile_id.setter
    def tile_id(self, value: builtins.int) -> None:
        r"""
        Numeric part of tile_name for the antenna. Each pol has the same value
        e.g. tile_name "tile011" hsa tile_id of 11
        """
    @property
    def tile_name(self) -> builtins.str:
        r"""
        Human readable name of the antenna
        X and Y have the same name
        """
    @tile_name.setter
    def tile_name(self, value: builtins.str) -> None:
        r"""
        Human readable name of the antenna
        X and Y have the same name
        """
    @property
    def pol(self) -> Pol:
        r"""
        Polarisation - X or Y
        """
    @pol.setter
    def pol(self, value: Pol) -> None:
        r"""
        Polarisation - X or Y
        """
    @property
    def electrical_length_m(self) -> builtins.float:
        r"""
        Electrical length in metres for this antenna and polarisation to the receiver
        """
    @electrical_length_m.setter
    def electrical_length_m(self, value: builtins.float) -> None:
        r"""
        Electrical length in metres for this antenna and polarisation to the receiver
        """
    @property
    def north_m(self) -> builtins.float:
        r"""
        Antenna position North from the array centre (metres)
        """
    @north_m.setter
    def north_m(self, value: builtins.float) -> None:
        r"""
        Antenna position North from the array centre (metres)
        """
    @property
    def east_m(self) -> builtins.float:
        r"""
        Antenna position East from the array centre (metres)
        """
    @east_m.setter
    def east_m(self, value: builtins.float) -> None:
        r"""
        Antenna position East from the array centre (metres)
        """
    @property
    def height_m(self) -> builtins.float:
        r"""
        Antenna height from the array centre (metres)
        """
    @height_m.setter
    def height_m(self, value: builtins.float) -> None:
        r"""
        Antenna height from the array centre (metres)
        """
    @property
    def vcs_order(self) -> builtins.int:
        r"""
        AKA PFB to correlator input order (only relevant for pre V2 correlator)
        """
    @vcs_order.setter
    def vcs_order(self, value: builtins.int) -> None:
        r"""
        AKA PFB to correlator input order (only relevant for pre V2 correlator)
        """
    @property
    def subfile_order(self) -> builtins.int:
        r"""
        Subfile order is the order in which this rf_input is desired in our final output of data
        """
    @subfile_order.setter
    def subfile_order(self, value: builtins.int) -> None:
        r"""
        Subfile order is the order in which this rf_input is desired in our final output of data
        """
    @property
    def flagged(self) -> builtins.bool:
        r"""
        Is this rf_input flagged out (due to tile error, etc from metafits)
        """
    @flagged.setter
    def flagged(self, value: builtins.bool) -> None:
        r"""
        Is this rf_input flagged out (due to tile error, etc from metafits)
        """
    @property
    def digital_gains(self) -> builtins.list[builtins.float]:
        r"""
        Digital gains
        metafits digital gains will be divided by 64
        Digital gains are in mwalib metafits coarse channel order (ascending sky frequency order)
        """
    @digital_gains.setter
    def digital_gains(self, value: builtins.list[builtins.float]) -> None:
        r"""
        Digital gains
        metafits digital gains will be divided by 64
        Digital gains are in mwalib metafits coarse channel order (ascending sky frequency order)
        """
    @property
    def dipole_gains(self) -> builtins.list[builtins.float]:
        r"""
        Dipole gains.
        
        These are either 1 or 0 (on or off), depending on the dipole delay; a
        dipole delay of 32 corresponds to "dead dipole", so the dipole gain of 0
        reflects that. All other dipoles are assumed to be "live". The values
        are made floats for easy use in beam code.
        """
    @dipole_gains.setter
    def dipole_gains(self, value: builtins.list[builtins.float]) -> None:
        r"""
        Dipole gains.
        
        These are either 1 or 0 (on or off), depending on the dipole delay; a
        dipole delay of 32 corresponds to "dead dipole", so the dipole gain of 0
        reflects that. All other dipoles are assumed to be "live". The values
        are made floats for easy use in beam code.
        """
    @property
    def dipole_delays(self) -> builtins.list[builtins.int]:
        r"""
        Dipole delays
        """
    @dipole_delays.setter
    def dipole_delays(self, value: builtins.list[builtins.int]) -> None:
        r"""
        Dipole delays
        """
    @property
    def rec_number(self) -> builtins.int:
        r"""
        Receiver number
        """
    @rec_number.setter
    def rec_number(self, value: builtins.int) -> None:
        r"""
        Receiver number
        """
    @property
    def rec_slot_number(self) -> builtins.int:
        r"""
        Receiver slot number
        """
    @rec_slot_number.setter
    def rec_slot_number(self, value: builtins.int) -> None:
        r"""
        Receiver slot number
        """
    @property
    def rec_type(self) -> ReceiverType:
        r"""
        Receiver type
        """
    @rec_type.setter
    def rec_type(self, value: ReceiverType) -> None:
        r"""
        Receiver type
        """
    @property
    def flavour(self) -> builtins.str:
        r"""
        Cable Flavour
        """
    @flavour.setter
    def flavour(self, value: builtins.str) -> None:
        r"""
        Cable Flavour
        """
    @property
    def has_whitening_filter(self) -> builtins.bool:
        r"""
        Has whitening filter (depends on flavour)
        """
    @has_whitening_filter.setter
    def has_whitening_filter(self, value: builtins.bool) -> None:
        r"""
        Has whitening filter (depends on flavour)
        """
    @property
    def calib_delay(self) -> typing.Optional[builtins.float]:
        r"""
        Calibration delay in meters (if provided)
        If calibration solution information is not present in the metafits it will be `None`.
        When calibration solution information is present, some values of `calib_delay` may be NaN.
        Make sure you understand [how NaNs work in Rust](https://doc.rust-lang.org/std/primitive.f32.html) if you will be using this field!
        """
    @calib_delay.setter
    def calib_delay(self, value: typing.Optional[builtins.float]) -> None:
        r"""
        Calibration delay in meters (if provided)
        If calibration solution information is not present in the metafits it will be `None`.
        When calibration solution information is present, some values of `calib_delay` may be NaN.
        Make sure you understand [how NaNs work in Rust](https://doc.rust-lang.org/std/primitive.f32.html) if you will be using this field!
        """
    @property
    def calib_gains(self) -> typing.Optional[builtins.list[builtins.float]]:
        r"""
        Calibration gains (vector- 1 per coarse channel) if provided.  Channels are in `MetafitsContext.course_chans` order.
        If calibration solution information is not present in the metafits it will be `None`.
        When calibration solution information is present, some values of `calib_delay` may be NaN.
        Make sure you understand [how NaNs work in Rust](https://doc.rust-lang.org/std/primitive.f32.html) if you will be using this field!
        """
    @calib_gains.setter
    def calib_gains(self, value: typing.Optional[builtins.list[builtins.float]]) -> None:
        r"""
        Calibration gains (vector- 1 per coarse channel) if provided.  Channels are in `MetafitsContext.course_chans` order.
        If calibration solution information is not present in the metafits it will be `None`.
        When calibration solution information is present, some values of `calib_delay` may be NaN.
        Make sure you understand [how NaNs work in Rust](https://doc.rust-lang.org/std/primitive.f32.html) if you will be using this field!
        """
    @property
    def signal_chain_corrections_index(self) -> typing.Optional[builtins.int]:
        r"""
        Signal chain correction index
        This is the index into the MetafitsContext.signal_chain_corrections vector, or None if not applicable/not found for the
        receiver type and whitening filter combination
        """
    @signal_chain_corrections_index.setter
    def signal_chain_corrections_index(self, value: typing.Optional[builtins.int]) -> None:
        r"""
        Signal chain correction index
        This is the index into the MetafitsContext.signal_chain_corrections vector, or None if not applicable/not found for the
        receiver type and whitening filter combination
        """

@typing.final
class SignalChainCorrection:
    r"""
    Signal chain correction table
    """
    @property
    def receiver_type(self) -> ReceiverType:
        r"""
        Receiver Type
        """
    @receiver_type.setter
    def receiver_type(self, value: ReceiverType) -> None:
        r"""
        Receiver Type
        """
    @property
    def whitening_filter(self) -> builtins.bool:
        r"""
        Whitening Filter
        """
    @whitening_filter.setter
    def whitening_filter(self, value: builtins.bool) -> None:
        r"""
        Whitening Filter
        """
    @property
    def corrections(self) -> builtins.list[builtins.float]:
        r"""
        Corrections
        """
    @corrections.setter
    def corrections(self, value: builtins.list[builtins.float]) -> None:
        r"""
        Corrections
        """

@typing.final
class TimeStep:
    r"""
    This is a struct for our timesteps
    NOTE: correlator timesteps use unix time, voltage timesteps use gpstime, but we convert the two depending on what we are given
    """
    @property
    def unix_time_ms(self) -> builtins.int:
        r"""
        UNIX time (in milliseconds to avoid floating point inaccuracy)
        """
    @unix_time_ms.setter
    def unix_time_ms(self, value: builtins.int) -> None:
        r"""
        UNIX time (in milliseconds to avoid floating point inaccuracy)
        """
    @property
    def gps_time_ms(self) -> builtins.int:
        r"""
        gps time (in milliseconds)
        """
    @gps_time_ms.setter
    def gps_time_ms(self, value: builtins.int) -> None:
        r"""
        gps time (in milliseconds)
        """

@typing.final
class VoltageContext:
    r"""
    This represents the basic metadata and methods for an MWA voltage capture system (VCS) observation.
    """
    @property
    def metafits_context(self) -> MetafitsContext:
        r"""
        Observation Metadata obtained from the metafits file
        """
    @metafits_context.setter
    def metafits_context(self, value: MetafitsContext) -> None:
        r"""
        Observation Metadata obtained from the metafits file
        """
    @property
    def mwa_version(self) -> MWAVersion:
        r"""
        MWA version, derived from the files passed in
        """
    @mwa_version.setter
    def mwa_version(self, value: MWAVersion) -> None:
        r"""
        MWA version, derived from the files passed in
        """
    @property
    def timesteps(self) -> builtins.list[TimeStep]:
        r"""
        This is an array of all known timesteps (union of metafits and provided timesteps from data files). The only exception is when the metafits timesteps are
        offset from the provided timesteps, in which case see description in `timestep::populate_metafits_provided_superset_of_timesteps`.
        """
    @timesteps.setter
    def timesteps(self, value: builtins.list[TimeStep]) -> None:
        r"""
        This is an array of all known timesteps (union of metafits and provided timesteps from data files). The only exception is when the metafits timesteps are
        offset from the provided timesteps, in which case see description in `timestep::populate_metafits_provided_superset_of_timesteps`.
        """
    @property
    def num_timesteps(self) -> builtins.int:
        r"""
        Number of timesteps in the timesteps vector
        """
    @num_timesteps.setter
    def num_timesteps(self, value: builtins.int) -> None:
        r"""
        Number of timesteps in the timesteps vector
        """
    @property
    def timestep_duration_ms(self) -> builtins.int:
        r"""
        length in millseconds of each timestep
        """
    @timestep_duration_ms.setter
    def timestep_duration_ms(self, value: builtins.int) -> None:
        r"""
        length in millseconds of each timestep
        """
    @property
    def coarse_chans(self) -> builtins.list[CoarseChannel]:
        r"""
        Vector of coarse channel structs which is the same as the metafits provided coarse channels
        """
    @coarse_chans.setter
    def coarse_chans(self, value: builtins.list[CoarseChannel]) -> None:
        r"""
        Vector of coarse channel structs which is the same as the metafits provided coarse channels
        """
    @property
    def num_coarse_chans(self) -> builtins.int:
        r"""
        Number of coarse channels in coarse chans struct
        """
    @num_coarse_chans.setter
    def num_coarse_chans(self, value: builtins.int) -> None:
        r"""
        Number of coarse channels in coarse chans struct
        """
    @property
    def common_timestep_indices(self) -> builtins.list[builtins.int]:
        r"""
        Vector of (in)common timestep indices
        """
    @common_timestep_indices.setter
    def common_timestep_indices(self, value: builtins.list[builtins.int]) -> None:
        r"""
        Vector of (in)common timestep indices
        """
    @property
    def num_common_timesteps(self) -> builtins.int:
        r"""
        Number of common timesteps
        """
    @num_common_timesteps.setter
    def num_common_timesteps(self, value: builtins.int) -> None:
        r"""
        Number of common timesteps
        """
    @property
    def common_coarse_chan_indices(self) -> builtins.list[builtins.int]:
        r"""
        Vector of (in)common coarse channel indices
        """
    @common_coarse_chan_indices.setter
    def common_coarse_chan_indices(self, value: builtins.list[builtins.int]) -> None:
        r"""
        Vector of (in)common coarse channel indices
        """
    @property
    def num_common_coarse_chans(self) -> builtins.int:
        r"""
        Number of common coarse channels
        """
    @num_common_coarse_chans.setter
    def num_common_coarse_chans(self, value: builtins.int) -> None:
        r"""
        Number of common coarse channels
        """
    @property
    def common_start_unix_time_ms(self) -> builtins.int:
        r"""
        The start of the observation (the time that is common to all
        provided data files).
        """
    @common_start_unix_time_ms.setter
    def common_start_unix_time_ms(self, value: builtins.int) -> None:
        r"""
        The start of the observation (the time that is common to all
        provided data files).
        """
    @property
    def common_end_unix_time_ms(self) -> builtins.int:
        r"""
        `end_unix_time_ms` is the common end time of the observation
        i.e. start time of last common timestep plus integration time.
        """
    @common_end_unix_time_ms.setter
    def common_end_unix_time_ms(self, value: builtins.int) -> None:
        r"""
        `end_unix_time_ms` is the common end time of the observation
        i.e. start time of last common timestep plus integration time.
        """
    @property
    def common_start_gps_time_ms(self) -> builtins.int:
        r"""
        `start_unix_time_ms` but in GPS milliseconds
        """
    @common_start_gps_time_ms.setter
    def common_start_gps_time_ms(self, value: builtins.int) -> None:
        r"""
        `start_unix_time_ms` but in GPS milliseconds
        """
    @property
    def common_end_gps_time_ms(self) -> builtins.int:
        r"""
        `end_unix_time_ms` but in GPS milliseconds
        """
    @common_end_gps_time_ms.setter
    def common_end_gps_time_ms(self, value: builtins.int) -> None:
        r"""
        `end_unix_time_ms` but in GPS milliseconds
        """
    @property
    def common_duration_ms(self) -> builtins.int:
        r"""
        Total duration of common timesteps
        """
    @common_duration_ms.setter
    def common_duration_ms(self, value: builtins.int) -> None:
        r"""
        Total duration of common timesteps
        """
    @property
    def common_bandwidth_hz(self) -> builtins.int:
        r"""
        Total bandwidth of the common coarse channels
        """
    @common_bandwidth_hz.setter
    def common_bandwidth_hz(self, value: builtins.int) -> None:
        r"""
        Total bandwidth of the common coarse channels
        """
    @property
    def common_good_timestep_indices(self) -> builtins.list[builtins.int]:
        r"""
        Vector of (in)common timestep indices only including timesteps after the quack time
        """
    @common_good_timestep_indices.setter
    def common_good_timestep_indices(self, value: builtins.list[builtins.int]) -> None:
        r"""
        Vector of (in)common timestep indices only including timesteps after the quack time
        """
    @property
    def num_common_good_timesteps(self) -> builtins.int:
        r"""
        Number of common timesteps only including timesteps after the quack time
        """
    @num_common_good_timesteps.setter
    def num_common_good_timesteps(self, value: builtins.int) -> None:
        r"""
        Number of common timesteps only including timesteps after the quack time
        """
    @property
    def common_good_coarse_chan_indices(self) -> builtins.list[builtins.int]:
        r"""
        Vector of (in)common coarse channel indices only including timesteps after the quack time
        """
    @common_good_coarse_chan_indices.setter
    def common_good_coarse_chan_indices(self, value: builtins.list[builtins.int]) -> None:
        r"""
        Vector of (in)common coarse channel indices only including timesteps after the quack time
        """
    @property
    def num_common_good_coarse_chans(self) -> builtins.int:
        r"""
        Number of common coarse channels only including timesteps after the quack time
        """
    @num_common_good_coarse_chans.setter
    def num_common_good_coarse_chans(self, value: builtins.int) -> None:
        r"""
        Number of common coarse channels only including timesteps after the quack time
        """
    @property
    def common_good_start_unix_time_ms(self) -> builtins.int:
        r"""
        The start of the observation (the time that is common to all
        provided data files) only including timesteps after the quack time
        """
    @common_good_start_unix_time_ms.setter
    def common_good_start_unix_time_ms(self, value: builtins.int) -> None:
        r"""
        The start of the observation (the time that is common to all
        provided data files) only including timesteps after the quack time
        """
    @property
    def common_good_end_unix_time_ms(self) -> builtins.int:
        r"""
        `end_unix_time_ms` is the common end time of the observation only including timesteps after the quack time
        i.e. start time of last common timestep plus integration time.
        """
    @common_good_end_unix_time_ms.setter
    def common_good_end_unix_time_ms(self, value: builtins.int) -> None:
        r"""
        `end_unix_time_ms` is the common end time of the observation only including timesteps after the quack time
        i.e. start time of last common timestep plus integration time.
        """
    @property
    def common_good_start_gps_time_ms(self) -> builtins.int:
        r"""
        `common_good_start_unix_time_ms` but in GPS milliseconds
        """
    @common_good_start_gps_time_ms.setter
    def common_good_start_gps_time_ms(self, value: builtins.int) -> None:
        r"""
        `common_good_start_unix_time_ms` but in GPS milliseconds
        """
    @property
    def common_good_end_gps_time_ms(self) -> builtins.int:
        r"""
        `common_good_end_unix_time_ms` but in GPS milliseconds
        """
    @common_good_end_gps_time_ms.setter
    def common_good_end_gps_time_ms(self, value: builtins.int) -> None:
        r"""
        `common_good_end_unix_time_ms` but in GPS milliseconds
        """
    @property
    def common_good_duration_ms(self) -> builtins.int:
        r"""
        Total duration of common_good timesteps
        """
    @common_good_duration_ms.setter
    def common_good_duration_ms(self, value: builtins.int) -> None:
        r"""
        Total duration of common_good timesteps
        """
    @property
    def common_good_bandwidth_hz(self) -> builtins.int:
        r"""
        Total bandwidth of the common coarse channels only including timesteps after the quack time
        """
    @common_good_bandwidth_hz.setter
    def common_good_bandwidth_hz(self, value: builtins.int) -> None:
        r"""
        Total bandwidth of the common coarse channels only including timesteps after the quack time
        """
    @property
    def provided_timestep_indices(self) -> builtins.list[builtins.int]:
        r"""
        The indices of any timesteps which we have *some* data for
        """
    @provided_timestep_indices.setter
    def provided_timestep_indices(self, value: builtins.list[builtins.int]) -> None:
        r"""
        The indices of any timesteps which we have *some* data for
        """
    @property
    def num_provided_timesteps(self) -> builtins.int:
        r"""
        Number of provided timestep indices we have at least *some* data for
        """
    @num_provided_timesteps.setter
    def num_provided_timesteps(self, value: builtins.int) -> None:
        r"""
        Number of provided timestep indices we have at least *some* data for
        """
    @property
    def provided_coarse_chan_indices(self) -> builtins.list[builtins.int]:
        r"""
        The indices of any coarse channels which we have *some* data for
        """
    @provided_coarse_chan_indices.setter
    def provided_coarse_chan_indices(self, value: builtins.list[builtins.int]) -> None:
        r"""
        The indices of any coarse channels which we have *some* data for
        """
    @property
    def num_provided_coarse_chans(self) -> builtins.int:
        r"""
        Number of provided coarse channel indices we have at least *some* data for
        """
    @num_provided_coarse_chans.setter
    def num_provided_coarse_chans(self, value: builtins.int) -> None:
        r"""
        Number of provided coarse channel indices we have at least *some* data for
        """
    @property
    def coarse_chan_width_hz(self) -> builtins.int:
        r"""
        Bandwidth of each coarse channel
        """
    @coarse_chan_width_hz.setter
    def coarse_chan_width_hz(self, value: builtins.int) -> None:
        r"""
        Bandwidth of each coarse channel
        """
    @property
    def fine_chan_width_hz(self) -> builtins.int:
        r"""
        Volatge fine_chan_resolution (if applicable- MWA legacy is 10 kHz, MWAX is unchannelised i.e. the full coarse channel width)
        """
    @fine_chan_width_hz.setter
    def fine_chan_width_hz(self, value: builtins.int) -> None:
        r"""
        Volatge fine_chan_resolution (if applicable- MWA legacy is 10 kHz, MWAX is unchannelised i.e. the full coarse channel width)
        """
    @property
    def num_fine_chans_per_coarse(self) -> builtins.int:
        r"""
        Number of fine channels in each coarse channel
        """
    @num_fine_chans_per_coarse.setter
    def num_fine_chans_per_coarse(self, value: builtins.int) -> None:
        r"""
        Number of fine channels in each coarse channel
        """
    @property
    def sample_size_bytes(self) -> builtins.int:
        r"""
        Number of bytes in each sample (a sample is a complex, thus includes r and i)
        """
    @sample_size_bytes.setter
    def sample_size_bytes(self, value: builtins.int) -> None:
        r"""
        Number of bytes in each sample (a sample is a complex, thus includes r and i)
        """
    @property
    def num_voltage_blocks_per_timestep(self) -> builtins.int:
        r"""
        Number of voltage blocks per timestep
        """
    @num_voltage_blocks_per_timestep.setter
    def num_voltage_blocks_per_timestep(self, value: builtins.int) -> None:
        r"""
        Number of voltage blocks per timestep
        """
    @property
    def num_voltage_blocks_per_second(self) -> builtins.int:
        r"""
        Number of voltage blocks of samples in each second of data
        """
    @num_voltage_blocks_per_second.setter
    def num_voltage_blocks_per_second(self, value: builtins.int) -> None:
        r"""
        Number of voltage blocks of samples in each second of data
        """
    @property
    def num_samples_per_voltage_block(self) -> builtins.int:
        r"""
        Number of samples in each voltage_blocks for each second of data per rf_input * fine_chans * real|imag
        """
    @num_samples_per_voltage_block.setter
    def num_samples_per_voltage_block(self, value: builtins.int) -> None:
        r"""
        Number of samples in each voltage_blocks for each second of data per rf_input * fine_chans * real|imag
        """
    @property
    def voltage_block_size_bytes(self) -> builtins.int:
        r"""
        The size of each voltage block
        """
    @voltage_block_size_bytes.setter
    def voltage_block_size_bytes(self, value: builtins.int) -> None:
        r"""
        The size of each voltage block
        """
    @property
    def delay_block_size_bytes(self) -> builtins.int:
        r"""
        Number of bytes used to store delays - for MWAX this is the same as a voltage block size, for legacy it is 0
        """
    @delay_block_size_bytes.setter
    def delay_block_size_bytes(self, value: builtins.int) -> None:
        r"""
        Number of bytes used to store delays - for MWAX this is the same as a voltage block size, for legacy it is 0
        """
    @property
    def data_file_header_size_bytes(self) -> builtins.int:
        r"""
        The amount of bytes to skip before getting into real data within the voltage files
        """
    @data_file_header_size_bytes.setter
    def data_file_header_size_bytes(self, value: builtins.int) -> None:
        r"""
        The amount of bytes to skip before getting into real data within the voltage files
        """
    @property
    def expected_voltage_data_file_size_bytes(self) -> builtins.int:
        r"""
        Expected voltage file size
        """
    @expected_voltage_data_file_size_bytes.setter
    def expected_voltage_data_file_size_bytes(self, value: builtins.int) -> None:
        r"""
        Expected voltage file size
        """
    @property
    def voltage_batches(self) -> builtins.list[VoltageFileBatch]:
        r"""
        `voltage_batches` *must* be sorted appropriately. See
        `voltage::determine_voltage_batches`. The order of the filenames
        corresponds directly to other voltage-related objects
        (e.g. `voltage_hdu_limits`). Structured:
        `voltage_batches[batch][filename]`.
        """
    @voltage_batches.setter
    def voltage_batches(self, value: builtins.list[VoltageFileBatch]) -> None:
        r"""
        `voltage_batches` *must* be sorted appropriately. See
        `voltage::determine_voltage_batches`. The order of the filenames
        corresponds directly to other voltage-related objects
        (e.g. `voltage_hdu_limits`). Structured:
        `voltage_batches[batch][filename]`.
        """
    @property
    def voltage_time_map(self) -> builtins.dict[builtins.int, builtins.dict[builtins.int, builtins.str]]:
        r"""
        We assume as little as possible about the data layout in the voltage
        files; here, a `BTreeMap` contains each unique GPS time from every
        voltage file, which is associated with another `BTreeMap`, associating each
        voltage number with a voltage batch number and HDU index. The voltage
        number, batch number and HDU index are everything needed to find the
        correct HDU out of all voltage files.
        """
    @voltage_time_map.setter
    def voltage_time_map(self, value: builtins.dict[builtins.int, builtins.dict[builtins.int, builtins.str]]) -> None:
        r"""
        We assume as little as possible about the data layout in the voltage
        files; here, a `BTreeMap` contains each unique GPS time from every
        voltage file, which is associated with another `BTreeMap`, associating each
        voltage number with a voltage batch number and HDU index. The voltage
        number, batch number and HDU index are everything needed to find the
        correct HDU out of all voltage files.
        """
    def __new__(cls, metafits_filename: builtins.str, voltage_filenames: typing.Sequence[builtins.str]) -> VoltageContext:
        r"""
        From a path to a metafits file and paths to voltage files, create a `VoltageContext`.
        
        Args:
            metafits_filename (str): filename of metafits file as a path or string.
            voltage_filenames (list[str]): list of filenames of voltage files.
        
        Returns:
            voltage_context (VoltageContext): a populated VoltageContext object if Ok.
        """
    def get_fine_chan_freqs_hz_array(self, volt_coarse_chan_indices: typing.Sequence[builtins.int]) -> builtins.list[builtins.float]:
        r"""
        For a given list of voltage coarse channel indices, return a list of the center frequencies for all the fine channels in the given coarse channels.
        
        Args:
            volt_coarse_chan_indices (list[int]): a list containing correlator coarse channel indices for which you want fine channels for. Does not need to be contiguous.
        
        Returns:
            fine_chan_freqs_hz_array (list[float]): a vector of floats containing the centre sky frequencies of all the fine channels for the given coarse channels.
        """
    def read_file(self, volt_timestep_index: builtins.int, volt_coarse_chan_index: builtins.int) -> numpy.typing.NDArray[numpy.int8]:
        r"""
        Read a single timestep / coarse channel worth of data
        
        Args:
            volt_timestep_index (int): index within the timestep array for the desired timestep. This corresponds to the element within VoltageContext.timesteps. For mwa legacy each index represents 1 second increments, for mwax it is 8 second increments.
            volt_coarse_chan_index (int): index within the coarse_chan array for the desired coarse channel. This corresponds to the element within VoltageContext.coarse_chans.
        
        Returns:
            data (numpy.typing.NDArray[numpy.int8]): A 6 dimensional ndarray of signed bytes containing the data, if Ok.
        
        NOTE: The shape of the ndarray is different between LegacyVCS and MWAX VCS
        Legacy: [second],[time sample],[chan],[ant],[pol],[complexity]
                where complexity is a byte (first 4 bits for real, second 4 bits for imaginary) in 2's compliment    
        MWAX  : [second],[voltage_block],[antenna],[pol],[sample],[r,i]
        """
    def read_second(self, gps_second_start: builtins.int, gps_second_count: builtins.int, volt_coarse_chan_index: builtins.int) -> numpy.typing.NDArray[numpy.int8]:
        r"""
        Read a single or multiple seconds of data for a coarse channel
        
        Args:
            gps_second_start (int): GPS second within the observation to start returning data.
            gps_second_count (int): number of seconds of data to return.
            volt_coarse_chan_index (int): index within the coarse_chan array for the desired coarse channel. This corresponds to the element within VoltageContext.coarse_chans.
        
        Returns:
            data (numpy.typing.NDArray[numpy.int8]): A 6 dimensional ndarray of signed bytes containing the data, if Ok.
        
        NOTE: The shape is different between LegacyVCS and MWAX VCS
        Legacy: [second],[time sample],[chan],[ant],[pol],[complexity]
                where complexity is a byte (first 4 bits for real, second 4 bits for imaginary) in 2's compliment    
        MWAX  : [second],[voltage_block],[antenna],[pol],[sample],[r,i]
        """
    def __repr__(self) -> builtins.str: ...
    def __enter__(self, slf: VoltageContext) -> VoltageContext: ...
    def __exit__(self, _exc_type: typing.Any, _exc_value: typing.Any, _traceback: typing.Any) -> None: ...

class VoltageErro(builtins.Exception):
    ...

class VoltageErrorEmptyBTreeMap(builtins.Exception):
    ...

class VoltageErrorGpsTimeMissing(builtins.Exception):
    ...

class VoltageErrorInvalidBufferSize(builtins.Exception):
    ...

class VoltageErrorInvalidCoarseChanIndex(builtins.Exception):
    ...

class VoltageErrorInvalidGpsSecondCount(builtins.Exception):
    ...

class VoltageErrorInvalidGpsSecondStart(builtins.Exception):
    ...

class VoltageErrorInvalidMwaVersion(builtins.Exception):
    ...

class VoltageErrorInvalidTimeStepIndex(builtins.Exception):
    ...

class VoltageErrorInvalidVoltageFileSize(builtins.Exception):
    ...

class VoltageErrorMetafitsObsidMismatch(builtins.Exception):
    ...

class VoltageErrorMissingObsid(builtins.Exception):
    ...

class VoltageErrorMixture(builtins.Exception):
    ...

class VoltageErrorNoDataForTimeStepCoarseChannel(builtins.Exception):
    ...

class VoltageErrorNoVoltageFiles(builtins.Exception):
    ...

class VoltageErrorObsidMismatch(builtins.Exception):
    ...

class VoltageErrorUnequalFileSizes(builtins.Exception):
    ...

class VoltageErrorUnevenChannelsForGpsTime(builtins.Exception):
    ...

class VoltageErrorUnrecognised(builtins.Exception):
    ...

@typing.final
class VoltageFile:
    r"""
    This represents one voltage file
    """
    @property
    def filename(self) -> builtins.str:
        r"""
        Filename of voltage file
        """
    @filename.setter
    def filename(self, value: builtins.str) -> None:
        r"""
        Filename of voltage file
        """
    @property
    def channel_identifier(self) -> builtins.int:
        r"""
        channel number (receiver channel number 001..255)
        """
    @channel_identifier.setter
    def channel_identifier(self, value: builtins.int) -> None:
        r"""
        channel number (receiver channel number 001..255)
        """

@typing.final
class VoltageFileBatch:
    r"""
    This represents one group of voltage files with the same "batch" identitifer (gps time).
    e.g.
    MWA Legacy: obsid_gpstime_datetime_chan
    MWAX      : obsid_gpstime_datetime_chan
    """
    @property
    def gps_time_seconds(self) -> builtins.int: ...
    @gps_time_seconds.setter
    def gps_time_seconds(self, value: builtins.int) -> None: ...
    @property
    def voltage_files(self) -> builtins.list[VoltageFile]:
        r"""
        Vector storing the details of each voltage file in this batch
        """
    @voltage_files.setter
    def voltage_files(self, value: builtins.list[VoltageFile]) -> None:
        r"""
        Vector storing the details of each voltage file in this batch
        """

@typing.final
class CableDelaysApplied(enum.Enum):
    r"""
    The type of cable delays applied to the data
    """
    NoCableDelaysApplied = ...
    CableAndRecClock = ...
    CableAndRecClockAndBeamformerDipoleDelays = ...

@typing.final
class GeometricDelaysApplied(enum.Enum):
    r"""
    The type of geometric delays applied to the data
    """
    No = ...
    Zenith = ...
    TilePointing = ...
    AzElTracking = ...

@typing.final
class MWAMode(enum.Enum):
    r"""
    The MODE the system was in for this observation
    """
    No_Capture = ...
    Burst_Vsib = ...
    Sw_Cor_Vsib = ...
    Hw_Cor_Pkts = ...
    Rts_32t = ...
    Hw_Lfiles = ...
    Hw_Lfiles_Nomentok = ...
    Sw_Cor_Vsib_Nomentok = ...
    Burst_Vsib_Synced = ...
    Burst_Vsib_Raw = ...
    Lfiles_Client = ...
    No_Capture_Burst = ...
    Enter_Burst = ...
    Enter_Channel = ...
    Voltage_Raw = ...
    Corr_Mode_Change = ...
    Voltage_Start = ...
    Voltage_Stop = ...
    Voltage_Buffer = ...
    Mwax_Correlator = ...
    Mwax_Vcs = ...
    Mwax_Buffer = ...

@typing.final
class MWAVersion(enum.Enum):
    r"""
    Enum for all of the known variants of file format based on Correlator version
    """
    CorrOldLegacy = ...
    r"""
    MWA correlator (v1.0), having data files without any batch numbers.
    """
    CorrLegacy = ...
    r"""
    MWA correlator (v1.0), having data files with "gpubox" and batch numbers in their names.
    """
    CorrMWAXv2 = ...
    r"""
    MWAX correlator (v2.0)
    """
    VCSLegacyRecombined = ...
    r"""
    Legacy VCS Recombined
    """
    VCSMWAXv2 = ...
    r"""
    MWAX VCS
    """

@typing.final
class Pol(enum.Enum):
    r"""
    Instrument polarisation.
    """
    X = ...
    Y = ...

@typing.final
class ReceiverType(enum.Enum):
    r"""
    ReceiverType enum.
    """
    Unknown = ...
    RRI = ...
    NI = ...
    Pseudo = ...
    SHAO = ...
    EDA2 = ...

@typing.final
class VisPol(enum.Enum):
    r"""
    Visibility polarisations
    """
    XX = ...
    XY = ...
    YX = ...
    YY = ...

